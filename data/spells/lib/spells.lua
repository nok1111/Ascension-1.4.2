--Pre-made areas

--Waves
AREA_WAVE3 = {
{1, 1, 1},
{1, 1, 1},
{0, 3, 0}
}

AREA_WAVEZ4 = {
{0, 1, 0},
{1, 3, 1},
{0, 1, 0}
}


AREA_WAVE4 = {
{1, 1, 1, 1, 1},
{0, 1, 1, 1, 0},
{0, 1, 1, 1, 0},
{0, 0, 3, 0, 0}
}

AREA_WAVEFIST= {
{1, 1, 1, 1, 1},
{0, 1, 1, 1, 0},
{0, 0, 3, 0, 0} 
}

AREA_WAVE6 = {
{0, 0, 0, 0, 0},
{0, 1, 3, 1, 0},
{0, 0, 0, 0, 0}
}

AREA_SQUAREWAVE5 = {
{1, 1, 1},
{1, 1, 1},
{1, 1, 1},
{0, 1, 0},
{0, 3, 0}
}

AREA_SQUAREWAVE51 = {
{0, 1, 0},
{0, 1, 0},
{0, 1, 0},
{0, 1, 0},
{0, 3, 0}
}

AREA_SQUAREWAVE52 = {
{1, 0, 1},
{1, 0, 1},
{1, 0, 1},
{1, 0, 1},
{0, 3, 0}
}

AREA_SQUAREWAVE53 = {
{1, 1, 1},
{1, 1, 1},
{1, 1, 1},
{1, 1, 1},
{0, 3, 0}
}

AREA_SQUAREWAVE6 = {
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0}
}

AREA_SQUAREWAVE7 = {
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0}
}

--Diagonal waves
AREADIAGONAL_WAVE4 = {
{0, 0, 0, 0, 1, 0},
{0, 0, 0, 1, 1, 0},
{0, 0, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 0},
{0, 0, 0, 0, 0, 3}
}

AREADIAGONAL_SQUAREWAVE5 = {
{1, 1, 1, 0, 0},
{1, 1, 1, 0, 0},
{1, 1, 1, 0, 0},
{0, 0, 0, 1, 0},
{0, 0, 0, 0, 3}
}

AREADIAGONAL_WAVE6 = {
{0, 0, 1},
{0, 3, 0},
{1, 0, 0}
}

--Beams
AREA_BEAM1 = {
{3}
}

AREA_BEAM5 = {
{1},
{1},
{1},
{1},
{3}
}

AREA_BEAM7 = {
{1},
{1},
{1},
{1},
{1},
{1},
{3}
}

AREA_BEAM8 = {
{1},
{1},
{1},
{1},
{1},
{1},
{1},
{3}
}

--Diagonal Beams
AREADIAGONAL_BEAM5 = {
{1, 0, 0, 0, 0},
{0, 1, 0, 0, 0},
{0, 0, 1, 0, 0},
{0, 0, 0, 1, 0},
{0, 0, 0, 0, 3}
}

AREADIAGONAL_BEAM7 = {
{1, 0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0, 3}
}

--Circles
AREA_CIRCLE2X2 = {
{0, 1, 1, 1, 0},
{1, 1, 1, 1, 1},
{1, 1, 3, 1, 1},
{1, 1, 1, 1, 1},
{0, 1, 1, 1, 0}
}

AREA_CIRCLE1X2 = {
{0, 0, 1, 0, 0},
{0, 1, 1, 1, 0},
{1, 1, 3, 1, 1},
{0, 1, 1, 1, 0},
{0, 0, 1, 0, 0}
}

AREA_CIRCLE3X3 = {
{0, 0, 1, 1, 1, 0, 0},
{0, 1, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 1, 1},
{1, 1, 1, 3, 1, 1, 1},
{1, 1, 1, 1, 1, 1, 1},
{0, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 0, 0}
}

-- Crosses
AREA_CROSS1X1 = {
{0, 1, 0},
{1, 3, 1},
{0, 1, 0}
}
AREA_CROSS0X0 = {
{0, 0, 0},
{0, 3, 0},
{0, 0, 0}
}

AREA_CROSS5X5 = {
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}
}

AREA_CROSS6X6 = {
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}
}

AREA_RANDOM1 = {
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}
}

AREA_RANDOM2 = {
{1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 1},
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}
}

AREA_CIRCLE5X5 = {
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}
}

AREA_CIRCLE4X4 = {
    {0, 0, 1, 1, 1, 0, 0},
    {0, 1, 1, 1, 1, 1, 0},
    {1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 3, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1},
    {0, 1, 1, 1, 1, 1, 0},
    {0, 0, 1, 1, 1, 0, 0}
}

AREA_CIRCLE6X6 = {
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
{0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}
}

--Squares
AREA_SQUARE1X1 = {
{1, 1, 1},
{1, 3, 1},
{1, 1, 1}
}
AREA_SQUARENXN = {
{0, 0, 0},
{0, 3, 0},
{0, 0, 0}
}
AREA_SQUARE2X2 = {
{0, 1, 1, 1, 0},
{1, 1, 1, 1, 1},
{1, 1, 3, 1, 1},
{1, 1, 1, 1, 1},
{0, 1, 1, 1, 0},
}
-- Walls
AREA_WALLFIELD = {
{1, 1, 3, 1, 1}
}

AREADIAGONAL_WALLFIELD = {
{0, 0, 0, 0, 1},
{0, 0, 0, 1, 1},
{0, 1, 3, 1, 0},
{1, 1, 0, 0, 0},
{1, 0, 0, 0, 0},
}

-- This array contains all destroyable field items
FIELDS = {1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1500,1501,1502,1503,1504}

function Player:addPartyCondition(combat, variant, condition, baseMana)
	local party = self:getParty()
	if not party then
		self:sendCancelMessage(RETURNVALUE_NOPARTYMEMBERSINRANGE)
		self:getPosition():sendMagicEffect(CONST_ME_POFF)
		return false
	end

	local positions = combat:getPositions(self, variant)
	local members = party:getMembers()
	members[#members + 1] = party:getLeader()

	local affectedMembers = {}
	for _, member in ipairs(members) do
		local memberPosition = member:getPosition()
		for _, position in ipairs(positions) do
			if memberPosition == position then
				affectedMembers[#affectedMembers + 1] = member
			end
		end
	end

	if #affectedMembers <= 1 then
		self:sendCancelMessage(RETURNVALUE_NOPARTYMEMBERSINRANGE)
		self:getPosition():sendMagicEffect(CONST_ME_POFF)
		return false
	end

	local mana = math.ceil(#affectedMembers * math.pow(0.9, #affectedMembers - 1) * baseMana)
	if self:getMana() < mana then
		self:sendCancelMessage(RETURNVALUE_NOTENOUGHMANA)
		self:getPosition():sendMagicEffect(CONST_ME_POFF)
		return false
	end

	self:addMana(-mana)
	self:addManaSpent(mana)

	for _, member in ipairs(affectedMembers) do
		member:addCondition(condition)
	end

	for _, position in ipairs(positions) do
		position:sendMagicEffect(CONST_ME_MAGIC_BLUE)
	end
	return true
end

function Player:conjureItem(reagentId, conjureId, conjureCount, effect)
	if not conjureCount and conjureId ~= 0 then
		local itemType = ItemType(conjureId)
		if itemType:getId() == 0 then
			return false
		end

		local charges = itemType:getCharges()
		if charges ~= 0 then
			conjureCount = charges
		end
	end

	if reagentId ~= 0 and not self:removeItem(reagentId, 1, -1) then
		self:sendCancelMessage(RETURNVALUE_YOUNEEDAMAGICITEMTOCASTSPELL)
		self:getPosition():sendMagicEffect(CONST_ME_POFF)
		return false
	end

	local item = self:addItem(conjureId, conjureCount)
	if not item then
		self:sendCancelMessage(RETURNVALUE_NOTPOSSIBLE)
		self:getPosition():sendMagicEffect(CONST_ME_POFF)
		return false
	end

	if item:hasAttribute(ITEM_ATTRIBUTE_DURATION) then
		item:decay()
	end

	self:getPosition():sendMagicEffect(item:getType():isRune() and CONST_ME_MAGIC_RED or effect)
	return true
end

function Creature:addAttributeCondition(parameters)
	local condition = Condition(CONDITION_ATTRIBUTES)
	for _, parameter in ipairs(parameters) do
		if parameter.key and parameter.value then
			condition:setParameter(parameter.key, parameter.value)
		end
	end

	self:addCondition(condition)
end

function isWalkable(position, checkCreature, isProjectil, checkInPz)
    local tile = Tile(position)
    if tile then
        if not tile:getThing(0) then
            return false
        end
        if tile:getCreatureCount() > 0 and checkCreature then
            return false
        end
        if tile:hasFlag(TILESTATE_PROTECTIONZONE) and checkInPz then
            return false, true
        end
        local n = not isProjectil and 3 or 2
        if tile:getItemCount() > 0 and tile:getCreatureCount() == 0 then
            if tile:hasProperty(n) or tile:hasProperty(7) then
                return false
            end
        end
        return true
    end
    return false
end

function getPositionsAround(pos)
    return {
        [1] = Position(pos.x, pos.y -1, pos.z),
        [2] = Position(pos.x + 1, pos.y - 1, pos.z),
        [3] = Position(pos.x + 1, pos.y, pos.z),
        [4] = Position(pos.x + 1, pos.y + 1, pos.z),
        [5] = Position(pos.x, pos.y + 1, pos.z),
        [6] = Position(pos.x - 1, pos.y + 1, pos.z),
        [7] = Position(pos.x - 1, pos.y, pos.z),
        [8] = Position(pos.x - 1, pos.y - 1, pos.z)
    }
end

function getDirectionTo(fromPos, toPos)
	local dir
	local x_offset = (fromPos.x - toPos.x)
	if (x_offset < 0) then
		dir = DIRECTION_EAST
		x_offset = math.abs(x_offset)
	else
		dir = DIRECTION_WEST
	end

	local y_offset = fromPos.y - toPos.y
	if (y_offset >= 0) then
		if (y_offset > x_offset) then
			dir = DIRECTION_NORTH
		elseif (y_offset == x_offset) then
			if (dir == DIRECTION_EAST) then
				dir = DIRECTION_NORTHEAST
			else
				dir = DIRECTION_NORTHWEST
			end
		end
	else
		y_offset = math.abs(y_offset)
		if (y_offset > x_offset) then
			dir = DIRECTION_SOUTH
		elseif (y_offset == x_offset) then
			if (dir == DIRECTION_EAST) then
				dir = DIRECTION_SOUTHEAST
			else
				dir = DIRECTION_SOUTHWEST
			end
		end
	end
	return dir
end

function getDistanceBetween(fromPos, toPos)
	return math.abs(fromPos.x - toPos.x) + math.abs(fromPos.y - toPos.y) + math.abs(fromPos.z - toPos.z)
end

Position.directionOffset = {
	[DIRECTION_NORTH] = {x = 0, y = -1},
	[DIRECTION_EAST] = {x = 1, y = 0},
	[DIRECTION_SOUTH] = {x = 0, y = 1},
	[DIRECTION_WEST] = {x = -1, y = 0},
	[DIRECTION_SOUTHWEST] = {x = -1, y = 1},
	[DIRECTION_SOUTHEAST] = {x = 1, y = 1},
	[DIRECTION_NORTHWEST] = {x = -1, y = -1},
	[DIRECTION_NORTHEAST] = {x = 1, y = -1}
}

function Position:setDirectionOffset(dir)
    local tmp = Position.directionOffset[dir]
    if not tmp then
        return self
    end
    return Position(self.x + tmp.x, self.y + tmp.y, self.z)
end

function getPosByDir(position, direction, steps)
	local offset = Position.directionOffset[direction]
	if offset then
		steps = steps or 1
		position.x = position.x + offset.x * steps
		position.y = position.y + offset.y * steps
	end
	return position
end

function checkInterceptions(creature, pos, toPos, cond)
    local p = pos
    local dir = getDirectionTo(pos, toPos)
    local d = getDistanceBetween(pos, toPos)
    if dir < DIRECTION_SOUTHWEST then
        while d > 0 do
            dir = getDirectionTo(p, toPos)
            p = getPosByDir(p, dir, 1)
            d = getDistanceBetween(p, toPos)
            if not isWalkable(p, true, true, true) then
                return p
            end
        end
    else
        local creature = cond or true
        local nextPositions = {pos}
        local tam = 1
        while d > 0 do
            local i = tam
            if tam > 2 then tam = 2 end
            local positions = getPositionsAround(nextPositions[tam])
            if (dir == DIRECTION_SOUTHWEST and (nextPositions[tam].x < toPos.x or nextPositions[tam].y > toPos.y))
            or (dir == DIRECTION_NORTHEAST and (nextPositions[tam].x > toPos.x or nextPositions[tam].y < toPos.y)) then
                positions = getPositionsAround(nextPositions[tam+1])
            end
            if dir == DIRECTION_SOUTHEAST and (nextPositions[tam].x > toPos.x or nextPositions[tam].y > toPos.y)
            or (dir == DIRECTION_NORTHWEST and (nextPositions[tam].x < toPos.x or nextPositions[tam].y < toPos.y)) then
                positions = getPositionsAround(nextPositions[tam-1])
            end
            d = getDistanceBetween(nextPositions[tam], toPos)
            tam = 0
            if d == 0 then break end
            local sum = 0
            if dir == DIRECTION_SOUTHWEST then sum = 4
            elseif dir == DIRECTION_SOUTHEAST then sum = 2
            elseif dir == DIRECTION_NORTHWEST then sum = 6
            elseif dir == DIRECTION_SOUTHEAST then sum = 0 end
            for j=1, 3 do
                local index = j+sum
                local check = 0
                if index > #positions then index = 1 end
                if dir == DIRECTION_SOUTHWEST and (positions[index].x < toPos.x or positions[index].y > toPos.y)
                or (dir == DIRECTION_SOUTHEAST and (positions[index].x > toPos.x or positions[index].y > toPos.y))
                or (dir == DIRECTION_NORTHWEST and (positions[index].x < toPos.x or positions[index].y < toPos.y))
                or (dir == DIRECTION_NORTHEAST and (positions[index].x > toPos.x or positions[index].y < toPos.y)) then
                    check = 1
                end
                local dx, dy = math.abs(positions[index].x - toPos.x) , math.abs(positions[index].y - toPos.y)
                if dx == dy and (positions[index].x == pos.x or positions[index].y == pos.y)
                and ((getDistanceBetween(positions[index], pos) > 1 and getDistanceBetween(positions[index], toPos) > 1)
                or getDistanceBetween(positions[index], pos) > 5 and getDistanceBetween(positions[index], toPos) > 0)then
                    check = 1
                end
                if getDistanceBetween(positions[index], toPos) == 0 then return toPos end
                if getDistanceBetween(positions[index], toPos) < d and check == 0 then
                    if not isWalkable(positions[index], creature, true, true) then
                        return positions[index]
                    end
                    tam = tam + 1
                    nextPositions[tam] = positions[index]
                end
            end
        end
    end
    return toPos
end

function setSpellTarget(player, variant)
	if variant.pos then
        variant.pos = checkInterceptions(player, player:getPosition(), variant.pos)
    end
    if isCreature(variant.number) then
    	local creature = Creature(variant.number)
        variant.pos = checkInterceptions(player, player:getPosition(), creature:getPosition())
        local findCreature = Tile(variant.pos):getTopVisibleCreature(creature)
        if getDistanceBetween(variant.pos, creature:getPosition()) ~= 0 and findCreature then
            variant.number = findCreature.uid
        elseif not findCreature then
            variant.number = 0
            player:sendCancelMessage("Target not reachable.")
        end
    end
    return variant
end

function rotate_CCW_90(m)
   local rotated = {}
   for c, m_1_c in ipairs(m[1]) do
      local col = {m_1_c}
      for r = 2, #m do
         col[r] = m[r][c]
      end
      table.insert(rotated, 1, col)
   end
   return rotated
end

function rotate_180(m)
   return rotate_CCW_90(rotate_CCW_90(m))
end

function rotate_CW_90(m)
   return rotate_CCW_90(rotate_CCW_90(rotate_CCW_90(m)))
end